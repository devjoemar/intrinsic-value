package com.devjoemar.intrinsicvalue.service;

import com.devjoemar.intrinsicvalue.api.IntrinsicValueCalculationDto;
import com.devjoemar.intrinsicvalue.api.IntrinsicValueResponse;
import org.springframework.stereotype.Service;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.math.MathContext;
import java.util.ArrayList;
import java.util.List;

/**
 * Service class for calculating the intrinsic value of a stock.
 * <p>
 * <b>Purpose:</b> This class estimates the inherent worth of a stock based on its expected future cash flows.
 * It helps investors determine whether a stock is overvalued or undervalued compared to its current market price.
 * </p>
 * <p>
 * <b>Key Concepts:</b>
 * <ul>
 *   <li><b>Free Cash Flow (FCF):</b> Cash generated by the company after accounting for capital expenditures,
 *   representing the cash available to investors.</li>
 *   <li><b>Growth Rate:</b> Expected annual growth rate of the company's FCF over the forecast period.</li>
 *   <li><b>Discount Rate:</b> Rate used to discount future cash flows to their present value, reflecting the time value of money and investment risk.</li>
 *   <li><b>Terminal Growth Rate:</b> Expected annual growth rate of the company's FCF beyond the forecast period.</li>
 *   <li><b>Net Debt:</b> Company's total debt minus its cash and cash equivalents, representing its financial obligations.</li>
 *   <li><b>Shares Outstanding:</b> Total number of shares held by all shareholders.</li>
 * </ul>
 * </p>
 * <p>
 * <b>Rationale Behind the Calculations:</b>
 * <ul>
 *   <li>Project future FCFs over a forecast period to estimate the company's ability to generate cash.</li>
 *   <li>Calculate the terminal value to estimate the company's value beyond the forecast period.</li>
 *   <li>Discount future cash flows and terminal value to present value to account for the time value of money.</li>
 *   <li>Adjust for net debt to reflect the company's financial obligations.</li>
 *   <li>Divide the total enterprise value by shares outstanding to get the intrinsic value per share.</li>
 *   <li><b>Multiplication by 1000:</b> Adjusts the units of the enterprise value from millions to thousands to match the units of shares outstanding, resulting in the intrinsic value per share in dollars.</li>
 * </ul>
 * </p>
 */
@Service
public class IntrinsicValueService {

    private static final int SCALE = 10;
    private static final int FORECAST_PERIOD_YEARS = 10;
    private static final MathContext HIGH_PRECISION_CONTEXT = MathContext.DECIMAL128;

    /**
     * Calculates the intrinsic value of a stock based on the given inputs.
     *
     * @param dto the intrinsic value calculation DTO containing the required parameters
     * @return the intrinsic value per share and a remark indicating if the stock is undervalued or overvalued
     * @throws IllegalArgumentException if input parameters are null or invalid
     * @throws ArithmeticException      if mathematical errors occur (e.g., division by zero)
     */
    public IntrinsicValueResponse calculateIntrinsicValue(IntrinsicValueCalculationDto dto) {

        validateInput(dto);

        final BigDecimal onePlusGrowthRate = BigDecimal.ONE.add(dto.getGrowthRate());
        final BigDecimal onePlusDiscountRate = BigDecimal.ONE.add(dto.getDiscountRate());

        final List<BigDecimal> forecastedFcfs = calculateForecastedFcfs(dto.getFcfLastYear(), onePlusGrowthRate);

        final BigDecimal terminalValue = calculateTerminalValue(dto, forecastedFcfs.get(FORECAST_PERIOD_YEARS - 1));

        final BigDecimal totalPresentValueOfFcfs = calculateTotalPresentValueOfFcfs(forecastedFcfs, onePlusDiscountRate);
        final BigDecimal presentValueOfTerminalValue = calculatePresentValue(terminalValue, onePlusDiscountRate, FORECAST_PERIOD_YEARS);

        final BigDecimal totalEnterpriseValue = totalPresentValueOfFcfs.add(presentValueOfTerminalValue);

        final BigDecimal adjustedTotalEnterpriseValue = totalEnterpriseValue.subtract(dto.getNetDebt());

        final BigDecimal intrinsicValuePerShare = adjustedTotalEnterpriseValue.multiply(new BigDecimal("1000"))
                .divide(dto.getSharesOutstanding(), SCALE, RoundingMode.HALF_UP);

        final BigDecimal intrinsicValuePerShareRounded = intrinsicValuePerShare.setScale(2, RoundingMode.HALF_UP);

        final String remark = intrinsicValuePerShareRounded.compareTo(dto.getCurrentMarketPrice()) > 0 ? "Undervalued" : "Overvalued";

        return new IntrinsicValueResponse(intrinsicValuePerShareRounded, "USD", remark);
    }

    /**
     * Validates the input parameters to ensure they are not null and have valid values.
     *
     * @param dto the intrinsic value calculation DTO containing the input parameters
     * @throws IllegalArgumentException if any parameter is null or invalid
     */
    private void validateInput(IntrinsicValueCalculationDto dto) {
        if (dto == null) {
            throw new IllegalArgumentException("Input DTO cannot be null.");
        }
        if (dto.getFcfLastYear() == null
                || dto.getGrowthRate() == null
                || dto.getDiscountRate() == null
                || dto.getTerminalGrowthRate() == null
                || dto.getSharesOutstanding() == null
                || dto.getNetDebt() == null
                || dto.getCurrentMarketPrice() == null) {
            throw new IllegalArgumentException("One or more input parameters are null.");
        }
        if (dto.getSharesOutstanding().compareTo(BigDecimal.ZERO) <= 0) {
            throw new IllegalArgumentException("Shares outstanding must be greater than zero.");
        }
        if (dto.getDiscountRate().compareTo(BigDecimal.ZERO) <= 0) {
            throw new IllegalArgumentException("Discount rate must be greater than zero.");
        }
        if (dto.getDiscountRate().compareTo(dto.getTerminalGrowthRate()) == 0) {
            throw new IllegalArgumentException("Discount rate and terminal growth rate cannot be equal.");
        }
    }

    /**
     * Calculates the forecasted Free Cash Flows (FCFs) for the next forecast period.
     *
     * @param fcfLastYear       the Free Cash Flow from the last year
     * @param onePlusGrowthRate precomputed value of (1 + growth rate)
     * @return a list of forecasted FCFs
     */
    private List<BigDecimal> calculateForecastedFcfs(BigDecimal fcfLastYear, BigDecimal onePlusGrowthRate) {
        List<BigDecimal> forecastedFcfs = new ArrayList<>(FORECAST_PERIOD_YEARS);
        BigDecimal fcf = fcfLastYear.multiply(onePlusGrowthRate);
        forecastedFcfs.add(fcf);
        for (int year = 1; year < FORECAST_PERIOD_YEARS; year++) {
            fcf = fcf.multiply(onePlusGrowthRate);
            forecastedFcfs.add(fcf);
        }
        return forecastedFcfs;
    }

    /**
     * Calculates the terminal value based on the last forecasted FCF.
     * <p>
     * <b>Rationale:</b> The terminal value estimates the present value of all future cash flows beyond the forecast period,
     * assuming a perpetual growth rate. It's calculated using the Gordon Growth Model.
     * </p>
     *
     * @param dto     the intrinsic value calculation DTO containing the input parameters
     * @param lastFcf the last forecasted Free Cash Flow
     * @return the terminal value
     * @throws ArithmeticException if discount rate equals terminal growth rate
     */
    private BigDecimal calculateTerminalValue(IntrinsicValueCalculationDto dto, BigDecimal lastFcf) {
        BigDecimal denominator = dto.getDiscountRate().subtract(dto.getTerminalGrowthRate());
        if (denominator.compareTo(BigDecimal.ZERO) == 0) {
            throw new ArithmeticException("Discount rate and terminal growth rate cannot be equal.");
        }
        return lastFcf.multiply(BigDecimal.ONE.add(dto.getTerminalGrowthRate()))
                .divide(denominator, SCALE, RoundingMode.HALF_UP);
    }

    /**
     * Calculates the total present value of the forecasted FCFs.
     *
     * @param forecastedFcfs      the list of forecasted Free Cash Flows
     * @param onePlusDiscountRate precomputed value of (1 + discount rate)
     * @return the total present value of the forecasted FCFs
     */
    private BigDecimal calculateTotalPresentValueOfFcfs(List<BigDecimal> forecastedFcfs, BigDecimal onePlusDiscountRate) {
        BigDecimal totalPresentValue = BigDecimal.ZERO;
        for (int year = 0; year < forecastedFcfs.size(); year++) {
            BigDecimal presentValue = calculatePresentValue(forecastedFcfs.get(year), onePlusDiscountRate, year + 1);
            totalPresentValue = totalPresentValue.add(presentValue);
        }
        return totalPresentValue;
    }

    /**
     * Calculates the present value of a future amount.
     * <p>
     * <b>Rationale:</b> Discounting future cash flows to their present value accounts for the time value of money,
     * reflecting the idea that a dollar today is worth more than a dollar tomorrow.
     * </p>
     *
     * @param amount              the future amount
     * @param onePlusDiscountRate precomputed value of (1 + discount rate)
     * @param period              the number of periods until the amount is received
     * @return the present value of the future amount
     */
    private BigDecimal calculatePresentValue(BigDecimal amount, BigDecimal onePlusDiscountRate, int period) {
        BigDecimal discountFactor = onePlusDiscountRate.pow(period, HIGH_PRECISION_CONTEXT);
        return amount.divide(discountFactor, SCALE, RoundingMode.HALF_UP);
    }
}
